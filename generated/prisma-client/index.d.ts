// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  apartment: (where?: ApartmentWhereInput) => Promise<boolean>;
  inquiry: (where?: InquiryWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  vote: (where?: VoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  apartment: (where: ApartmentWhereUniqueInput) => ApartmentNullablePromise;
  apartments: (args?: {
    where?: ApartmentWhereInput;
    orderBy?: ApartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Apartment>;
  apartmentsConnection: (args?: {
    where?: ApartmentWhereInput;
    orderBy?: ApartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApartmentConnectionPromise;
  inquiry: (where: InquiryWhereUniqueInput) => InquiryNullablePromise;
  inquiries: (args?: {
    where?: InquiryWhereInput;
    orderBy?: InquiryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inquiry>;
  inquiriesConnection: (args?: {
    where?: InquiryWhereInput;
    orderBy?: InquiryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InquiryConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionNullablePromise;
  options: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Option>;
  optionsConnection: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionConnectionPromise;
  vote: (where: VoteWhereUniqueInput) => VoteNullablePromise;
  votes: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vote>;
  votesConnection: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApartment: (data: ApartmentCreateInput) => ApartmentPromise;
  updateApartment: (args: {
    data: ApartmentUpdateInput;
    where: ApartmentWhereUniqueInput;
  }) => ApartmentPromise;
  updateManyApartments: (args: {
    data: ApartmentUpdateManyMutationInput;
    where?: ApartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertApartment: (args: {
    where: ApartmentWhereUniqueInput;
    create: ApartmentCreateInput;
    update: ApartmentUpdateInput;
  }) => ApartmentPromise;
  deleteApartment: (where: ApartmentWhereUniqueInput) => ApartmentPromise;
  deleteManyApartments: (where?: ApartmentWhereInput) => BatchPayloadPromise;
  createInquiry: (data: InquiryCreateInput) => InquiryPromise;
  updateInquiry: (args: {
    data: InquiryUpdateInput;
    where: InquiryWhereUniqueInput;
  }) => InquiryPromise;
  updateManyInquiries: (args: {
    data: InquiryUpdateManyMutationInput;
    where?: InquiryWhereInput;
  }) => BatchPayloadPromise;
  upsertInquiry: (args: {
    where: InquiryWhereUniqueInput;
    create: InquiryCreateInput;
    update: InquiryUpdateInput;
  }) => InquiryPromise;
  deleteInquiry: (where: InquiryWhereUniqueInput) => InquiryPromise;
  deleteManyInquiries: (where?: InquiryWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (args: {
    data: OptionUpdateInput;
    where: OptionWhereUniqueInput;
  }) => OptionPromise;
  updateManyOptions: (args: {
    data: OptionUpdateManyMutationInput;
    where?: OptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOption: (args: {
    where: OptionWhereUniqueInput;
    create: OptionCreateInput;
    update: OptionUpdateInput;
  }) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createVote: (data: VoteCreateInput) => VotePromise;
  updateVote: (args: {
    data: VoteUpdateInput;
    where: VoteWhereUniqueInput;
  }) => VotePromise;
  updateManyVotes: (args: {
    data: VoteUpdateManyMutationInput;
    where?: VoteWhereInput;
  }) => BatchPayloadPromise;
  upsertVote: (args: {
    where: VoteWhereUniqueInput;
    create: VoteCreateInput;
    update: VoteUpdateInput;
  }) => VotePromise;
  deleteVote: (where: VoteWhereUniqueInput) => VotePromise;
  deleteManyVotes: (where?: VoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  apartment: (
    where?: ApartmentSubscriptionWhereInput
  ) => ApartmentSubscriptionPayloadSubscription;
  inquiry: (
    where?: InquirySubscriptionWhereInput
  ) => InquirySubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  vote: (
    where?: VoteSubscriptionWhereInput
  ) => VoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ApartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "handle_ASC"
  | "handle_DESC";

export type InquiryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC";

export type VoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "apartment_ASC"
  | "apartment_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ApartmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  handle?: Maybe<String>;
  handle_not?: Maybe<String>;
  handle_in?: Maybe<String[] | String>;
  handle_not_in?: Maybe<String[] | String>;
  handle_lt?: Maybe<String>;
  handle_lte?: Maybe<String>;
  handle_gt?: Maybe<String>;
  handle_gte?: Maybe<String>;
  handle_contains?: Maybe<String>;
  handle_not_contains?: Maybe<String>;
  handle_starts_with?: Maybe<String>;
  handle_not_starts_with?: Maybe<String>;
  handle_ends_with?: Maybe<String>;
  handle_not_ends_with?: Maybe<String>;
  AND?: Maybe<ApartmentWhereInput[] | ApartmentWhereInput>;
  OR?: Maybe<ApartmentWhereInput[] | ApartmentWhereInput>;
  NOT?: Maybe<ApartmentWhereInput[] | ApartmentWhereInput>;
}

export type InquiryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface InquiryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  apartment?: Maybe<ApartmentWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<InquiryWhereInput[] | InquiryWhereInput>;
  OR?: Maybe<InquiryWhereInput[] | InquiryWhereInput>;
  NOT?: Maybe<InquiryWhereInput[] | InquiryWhereInput>;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  OR?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  NOT?: Maybe<OptionWhereInput[] | OptionWhereInput>;
}

export type VoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  apartment?: Maybe<String>;
}>;

export interface VoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  apartment?: Maybe<String>;
  apartment_not?: Maybe<String>;
  apartment_in?: Maybe<String[] | String>;
  apartment_not_in?: Maybe<String[] | String>;
  apartment_lt?: Maybe<String>;
  apartment_lte?: Maybe<String>;
  apartment_gt?: Maybe<String>;
  apartment_gte?: Maybe<String>;
  apartment_contains?: Maybe<String>;
  apartment_not_contains?: Maybe<String>;
  apartment_starts_with?: Maybe<String>;
  apartment_not_starts_with?: Maybe<String>;
  apartment_ends_with?: Maybe<String>;
  apartment_not_ends_with?: Maybe<String>;
  option?: Maybe<OptionWhereInput>;
  AND?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  OR?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  NOT?: Maybe<VoteWhereInput[] | VoteWhereInput>;
}

export interface ApartmentCreateInput {
  id?: Maybe<ID_Input>;
  handle: String;
}

export interface ApartmentUpdateInput {
  handle?: Maybe<String>;
}

export interface ApartmentUpdateManyMutationInput {
  handle?: Maybe<String>;
}

export interface InquiryCreateInput {
  id?: Maybe<ID_Input>;
  apartment: ApartmentCreateOneInput;
  email: String;
}

export interface ApartmentCreateOneInput {
  create?: Maybe<ApartmentCreateInput>;
  connect?: Maybe<ApartmentWhereUniqueInput>;
}

export interface InquiryUpdateInput {
  apartment?: Maybe<ApartmentUpdateOneRequiredInput>;
  email?: Maybe<String>;
}

export interface ApartmentUpdateOneRequiredInput {
  create?: Maybe<ApartmentCreateInput>;
  update?: Maybe<ApartmentUpdateDataInput>;
  upsert?: Maybe<ApartmentUpsertNestedInput>;
  connect?: Maybe<ApartmentWhereUniqueInput>;
}

export interface ApartmentUpdateDataInput {
  handle?: Maybe<String>;
}

export interface ApartmentUpsertNestedInput {
  update: ApartmentUpdateDataInput;
  create: ApartmentCreateInput;
}

export interface InquiryUpdateManyMutationInput {
  email?: Maybe<String>;
}

export interface OptionCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
}

export interface OptionUpdateInput {
  title?: Maybe<String>;
}

export interface OptionUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface VoteCreateInput {
  id?: Maybe<ID_Input>;
  apartment: String;
  option: OptionCreateOneInput;
}

export interface OptionCreateOneInput {
  create?: Maybe<OptionCreateInput>;
  connect?: Maybe<OptionWhereUniqueInput>;
}

export interface VoteUpdateInput {
  apartment?: Maybe<String>;
  option?: Maybe<OptionUpdateOneRequiredInput>;
}

export interface OptionUpdateOneRequiredInput {
  create?: Maybe<OptionCreateInput>;
  update?: Maybe<OptionUpdateDataInput>;
  upsert?: Maybe<OptionUpsertNestedInput>;
  connect?: Maybe<OptionWhereUniqueInput>;
}

export interface OptionUpdateDataInput {
  title?: Maybe<String>;
}

export interface OptionUpsertNestedInput {
  update: OptionUpdateDataInput;
  create: OptionCreateInput;
}

export interface VoteUpdateManyMutationInput {
  apartment?: Maybe<String>;
}

export interface ApartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApartmentWhereInput>;
  AND?: Maybe<
    ApartmentSubscriptionWhereInput[] | ApartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApartmentSubscriptionWhereInput[] | ApartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApartmentSubscriptionWhereInput[] | ApartmentSubscriptionWhereInput
  >;
}

export interface InquirySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InquiryWhereInput>;
  AND?: Maybe<InquirySubscriptionWhereInput[] | InquirySubscriptionWhereInput>;
  OR?: Maybe<InquirySubscriptionWhereInput[] | InquirySubscriptionWhereInput>;
  NOT?: Maybe<InquirySubscriptionWhereInput[] | InquirySubscriptionWhereInput>;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OptionWhereInput>;
  AND?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  OR?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  NOT?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
}

export interface VoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoteWhereInput>;
  AND?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  OR?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  NOT?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Apartment {
  id: ID_Output;
  handle: String;
}

export interface ApartmentPromise extends Promise<Apartment>, Fragmentable {
  id: () => Promise<ID_Output>;
  handle: () => Promise<String>;
}

export interface ApartmentSubscription
  extends Promise<AsyncIterator<Apartment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  handle: () => Promise<AsyncIterator<String>>;
}

export interface ApartmentNullablePromise
  extends Promise<Apartment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  handle: () => Promise<String>;
}

export interface ApartmentConnection {
  pageInfo: PageInfo;
  edges: ApartmentEdge[];
}

export interface ApartmentConnectionPromise
  extends Promise<ApartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApartmentEdge>>() => T;
  aggregate: <T = AggregateApartmentPromise>() => T;
}

export interface ApartmentConnectionSubscription
  extends Promise<AsyncIterator<ApartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApartmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApartmentEdge {
  node: Apartment;
  cursor: String;
}

export interface ApartmentEdgePromise
  extends Promise<ApartmentEdge>,
    Fragmentable {
  node: <T = ApartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApartmentEdgeSubscription
  extends Promise<AsyncIterator<ApartmentEdge>>,
    Fragmentable {
  node: <T = ApartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApartment {
  count: Int;
}

export interface AggregateApartmentPromise
  extends Promise<AggregateApartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApartmentSubscription
  extends Promise<AsyncIterator<AggregateApartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Inquiry {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface InquiryPromise extends Promise<Inquiry>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  apartment: <T = ApartmentPromise>() => T;
  email: () => Promise<String>;
}

export interface InquirySubscription
  extends Promise<AsyncIterator<Inquiry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  apartment: <T = ApartmentSubscription>() => T;
  email: () => Promise<AsyncIterator<String>>;
}

export interface InquiryNullablePromise
  extends Promise<Inquiry | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  apartment: <T = ApartmentPromise>() => T;
  email: () => Promise<String>;
}

export interface InquiryConnection {
  pageInfo: PageInfo;
  edges: InquiryEdge[];
}

export interface InquiryConnectionPromise
  extends Promise<InquiryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InquiryEdge>>() => T;
  aggregate: <T = AggregateInquiryPromise>() => T;
}

export interface InquiryConnectionSubscription
  extends Promise<AsyncIterator<InquiryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InquiryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInquirySubscription>() => T;
}

export interface InquiryEdge {
  node: Inquiry;
  cursor: String;
}

export interface InquiryEdgePromise extends Promise<InquiryEdge>, Fragmentable {
  node: <T = InquiryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InquiryEdgeSubscription
  extends Promise<AsyncIterator<InquiryEdge>>,
    Fragmentable {
  node: <T = InquirySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInquiry {
  count: Int;
}

export interface AggregateInquiryPromise
  extends Promise<AggregateInquiry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInquirySubscription
  extends Promise<AsyncIterator<AggregateInquiry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Option {
  id: ID_Output;
  title: String;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface OptionNullablePromise
  extends Promise<Option | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Vote {
  id: ID_Output;
  createdAt: DateTimeOutput;
  apartment: String;
}

export interface VotePromise extends Promise<Vote>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  apartment: () => Promise<String>;
  option: <T = OptionPromise>() => T;
}

export interface VoteSubscription
  extends Promise<AsyncIterator<Vote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  apartment: () => Promise<AsyncIterator<String>>;
  option: <T = OptionSubscription>() => T;
}

export interface VoteNullablePromise
  extends Promise<Vote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  apartment: () => Promise<String>;
  option: <T = OptionPromise>() => T;
}

export interface VoteConnection {
  pageInfo: PageInfo;
  edges: VoteEdge[];
}

export interface VoteConnectionPromise
  extends Promise<VoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoteEdge>>() => T;
  aggregate: <T = AggregateVotePromise>() => T;
}

export interface VoteConnectionSubscription
  extends Promise<AsyncIterator<VoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoteSubscription>() => T;
}

export interface VoteEdge {
  node: Vote;
  cursor: String;
}

export interface VoteEdgePromise extends Promise<VoteEdge>, Fragmentable {
  node: <T = VotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoteEdgeSubscription
  extends Promise<AsyncIterator<VoteEdge>>,
    Fragmentable {
  node: <T = VoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVote {
  count: Int;
}

export interface AggregateVotePromise
  extends Promise<AggregateVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoteSubscription
  extends Promise<AsyncIterator<AggregateVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApartmentSubscriptionPayload {
  mutation: MutationType;
  node: Apartment;
  updatedFields: String[];
  previousValues: ApartmentPreviousValues;
}

export interface ApartmentSubscriptionPayloadPromise
  extends Promise<ApartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApartmentPreviousValuesPromise>() => T;
}

export interface ApartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApartmentPreviousValuesSubscription>() => T;
}

export interface ApartmentPreviousValues {
  id: ID_Output;
  handle: String;
}

export interface ApartmentPreviousValuesPromise
  extends Promise<ApartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  handle: () => Promise<String>;
}

export interface ApartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ApartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  handle: () => Promise<AsyncIterator<String>>;
}

export interface InquirySubscriptionPayload {
  mutation: MutationType;
  node: Inquiry;
  updatedFields: String[];
  previousValues: InquiryPreviousValues;
}

export interface InquirySubscriptionPayloadPromise
  extends Promise<InquirySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InquiryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InquiryPreviousValuesPromise>() => T;
}

export interface InquirySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InquirySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InquirySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InquiryPreviousValuesSubscription>() => T;
}

export interface InquiryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface InquiryPreviousValuesPromise
  extends Promise<InquiryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface InquiryPreviousValuesSubscription
  extends Promise<AsyncIterator<InquiryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface OptionPreviousValues {
  id: ID_Output;
  title: String;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface VoteSubscriptionPayload {
  mutation: MutationType;
  node: Vote;
  updatedFields: String[];
  previousValues: VotePreviousValues;
}

export interface VoteSubscriptionPayloadPromise
  extends Promise<VoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotePreviousValuesPromise>() => T;
}

export interface VoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotePreviousValuesSubscription>() => T;
}

export interface VotePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  apartment: String;
}

export interface VotePreviousValuesPromise
  extends Promise<VotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  apartment: () => Promise<String>;
}

export interface VotePreviousValuesSubscription
  extends Promise<AsyncIterator<VotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  apartment: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Inquiry",
    embedded: false
  },
  {
    name: "Vote",
    embedded: false
  },
  {
    name: "Apartment",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
